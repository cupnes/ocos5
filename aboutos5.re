= OS5について
== OS5とは
OS5は、勉強のためにフルスクラッチで作成しているOSです。ブートローダー・カーネル・ユーザーランド(カーネル上で動作するアプリケーション群)を含んでいます。現在の主なスペックは以下の通りです。

 * x86のQEMU(qemu-system-i386)で動作
 * 一番作りこめているのはカーネルで、主な機能を一通り備えている
 ** 時間管理
 ** タスク管理(スケジューラ、タスクローダ)
 ** メモリ管理(ページング、ヒープアロケータ)
 ** デバイスドライバ
 ** システムコール
 ** ファイルシステム
 * ユーザーランド(アプリケーション郡)は、まだカーネルの動作確認程度
 ** CUIのみ
 ** コマンドライン引数対応
 ** 静的ライブラリ対応(libkernel、libcommon、libstring、libconsole)
 * RAM上で動作
 ** ファイルシステムもRAM上
 ** コンベンショナルメモリ(640KB)に収まっている
 * ビルド環境はMakeとGCC
 ** アセンブラはGAS
 * スモールスタートとして、シンプルに(割りきって)実装している
 ** 一通りの機能を備えたカーネルが2000行程度

現状、一番作りこめているのはカーネルで、カーネルが持つべき主要な機能を一通り揃えています。カーネルが持つ機能について@<img>{os5_struct}に示します。

//image[os5_struct][OS5カーネルの構成]{
//}

スモールスタートとして、シンプルに割り切って実装するようにしています。@<img>{os5_struct}に示す一通りの機能を備えたカーネルが2000行程度で、ブートローダーとユーザーランドを合わせても3000行程度で実現できています(そのため、「本にしてみよう」と思い立ちました)。

機能実装の節目でブログ記事を公開しており、記事公開の日付をバージョン番号にしています。これまでのリリース情報など、OS5の情報は以下のページにまとめています。なお、本書で対象とするバージョンは2017年1月現在の最新リリースであるblog-20170123です。

 * OS5のまとめ : @<href>{http://funlinux.org/os5/}

また、ソースコードはGitで管理しており、GitHub上にリポジトリがあります。

 * GitHub : @<href>{http://github.com/cupnes/os5/}

blog-20170123時点で、ソースコード行数(アセンブラとCの行数の総和)は、@<table>{code_lines}の通りとなりました。
//table[code_lines][ソースコード行数]{
項目	行数
------------
ブートローダー	328
カーネル	2117
ユーザーランド	541
//}

#@# なお、各ソースファイルの行数は@<table>{noc}のとおりです。(TODO: ページに収まるよう、表をまとめるか分割する)
#@# #@mapfile(codelist.re)
#@# #@end

===[column] "OS5"という名前の由来
"OS5"という名前は、「OS作りに4回挫折した」ことを示しています(過去に"OS"、"OS2"、"OS3"がありました)。Linux 0.01のソースコードから分岐してみたり、本を参考にしてみたりしていたのですが、どのやり方もしっくりこない思いがあり、途中で飽きてやめてしまいました。「OSを作りたい」という思いは変わらなかったので、やり方を変えて試していました。5回目にして、「ソースコードや本も読み、フルスクラッチでできる気がした」事と、「元となるものがあった場合、『元のOS+自身のパッチ』であり、『自分のOS』とは言いづらい」という思いに気づき、2015年3月頃からフルスクラッチで"OS5"の作成を始めました。

== ソースディレクトリ構成
OS5のソースディレクトリ構成は以下の通りです。

 * boot/
 ** ブートローダーのソースディレクトリ
 * kernel/
 ** カーネルのソースディレクトリ
 * apps/
 ** ユーザーランドのソースディレクトリ
 * tools/
 ** 各種ツールのソースディレクトリ
 * doc/
 ** ドキュメントのディレクトリ
 * Makefile
 ** 全体を管理するMakefile

以降の章では、boot、kernel、apps、toolsの各ディレクトリのソースコードを説明します。

ソースディレクトリ直下のMakefileについては、章を割くほどでもないので、この章で掲載します。内容は以下の通りです。

//listnum[Makefile][Makefile][make]{
all: fd.img

fd.img: boot/boot.bin kernel/kernel.bin apps/apps.img
	cat $+ > $@

boot/boot.bin:
	make -C boot

kernel/kernel.bin:
	make -C kernel

apps/apps.img:
	make -C apps

doc:
	make -C doc

clean:
	make -C boot clean
	make -C kernel clean
	make -C apps clean
	make -C doc clean
	rm -f *~ *.o *.bin *.dat *.img *.map

run: fd.img
	qemu-system-i386 -fda $<

.PHONY: boot/boot.bin kernel/kernel.bin apps/apps.img doc clean
//}

Makefileの書き方として、特に独特なことはしていません。このMakefileは、下位のbootディレクトリやkernelディレクトリ、appsディレクトリのMakefileを呼び出します。そして、下位の各ディレクトリの生成物(boot/boot.bin、kernel/kernel.bin、apps/apps.img)を、catで結合し、fd.img(OS5のフロッピーディスクイメージ)を生成します(Makefileの3行目)。

#@# fd.imgのバイナリの構成は(TODO)の通りです。

#@#  * (TODO: fd.imgのバイナリ構成を表す図/表を追加)

== メモリマップ
#@# === ブートローダー動作時
#@# //table[physaddrspaceboot][物理アドレス空間(ブートローダー動作時)]{
#@# アドレス	内容
#@# ------------
#@# 0x0000 0500	コンベンショナルメモリの先頭
#@# ....	....
#@# 0x0000 1000	スタックのベースアドレス
#@# ...	....
#@# 0x0000 7c00	ブートローダー(MBR)の先頭
#@# ...	....
#@# 0x0000 7dff	ブートローダー(MBR)の末尾
#@# 0x0000 7e00	FDからカーネル・ユーザーランドロード先の先頭
#@# ...	....
#@# 0x0001 ffff	FDからカーネル・ユーザーランドロード先の先頭
#@# ....	....
#@# 0x0009 0000	GDTの先頭
#@# ....	....
#@# 0x0009 0010	GDTの末尾
#@# ....	....
#@# 0x0009 ffff	コンベンショナルメモリの末尾
#@# //}

#@# === カーネル・ユーザーランド動作時
メモリマップを@<img>{memmap_phys}に示します。@<img>{memmap_phys}は、実際にカーネルやユーザーランド(ファイルシステム)等をRAM上にどのように配置するかを示しています。

//image[memmap_phys][物理アドレス空間のメモリマップ][scale=0.5]{
//}

なお、カーネルやアプリケーションは「仮想アドレス空間」というアドレス空間で動作します。事実とは別のアドレス空間を用意することで、「アプリケーションは必ず同じアドレスから始まる」といったことや、「アプリケーションはカーネルの空間にアクセスさせない」といったことを実現しています。
